## 리팩토링이란?

겉보기 동작은 그대로 유지하되,\
리팩토링 기법들을 이용하여, 코드를 이해하고 수정이 쉽도록 구조를 개선하는 작업이다.

좋은코드를 만들기 위한 작업으로, 좋은코드란 수정하기 쉬운 코드를 말한다.

> 특정한 방식에 따라 코드를 정리하는 것

> 동작을 보존하는 작은 단계들을 거쳐 코드의 수정들을 연결하여 큰 변화를 만들어내는 일

> 개발속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것

---

## 하는 이유

#### 소프트웨어 설계가 좋아진다.

단기목표만을 위해 코드를 수정하다보면 기반 구조가 무너지기 쉽다.\
규칙적인 리팩터링은 코드의 구조를 지탱해준다.

#### 소프트웨어를 이해하기 쉬워진다.

프로그램을 동작시키는 데만 신경쓰다보면, 다른개발자를 배려하지 못한다.\
코드의 목적이 더 잘 드러나게, 내 의도를 더 명확하게 전달하다록 개선함으로써, 추후에 다른 개발자나 혹은 내 자신이 이해하기 쉬운 코드로 만들 수 있다.

#### 개발 속도의 향상

새로운 기능을 추가할 때 2가지의 타입이 있다.

- 시간이 훨씬 오래 걸린다. (기존 코드베이스에 잘 녹여낼 방법을 찾기가 쉽지 않다.)
- 시간이 훨씬 단축된다. (기존에 작성한 코드를 최대한 활용한다.)

차이가 나는 원인은 소프트웨어 내부 품질(설계)에 있다.

대표적인 예로,

- `모듈화`가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다.
- `코드가 명확`하면 버그를 만들 가능성도 줄고 디버깅하기가 쉽다.

리팩토링을 하는데에만 해도 시간이 소요된다.\
개발하기도 바쁜데 리펙토링에 시간을 투자하는게 낭비처럼 보일 수도 있지만,\
꾸준한 리팩토링을 통해 설계를 지속해서 개선함으로써, 추후 개발의 시간을 단축시킬 수 있다.

---

## 법칙

- **작업이 `기능추가`인지 `리팩터링`인지를 명확히 구분하자.** \
  `기능추가`는 기존코드를 건드리지않고 새 기능만을 추가한다.
- **리팩터링하기 전과 후의 코드가 똑같이 동작해야 한다.**
- **반복작업이 3번이상 이루어지면 리팩토링 한다.**
- **무언가 수정하려 할 때는, 수정하기 쉽게 정돈하고 수정하자.**
- **단계를 굉장히 작은 단위로 나눠서 `리팩토링 - 컴파일 - 테스트 - 커밋` 한다** \
  단계를 잘게 나눠야 더 빠르게 처리하고, 코드는 깨지지않고, 총 작업시간을 단축할 수 있다.
- **기능을 추가하기 쉽도록 기존코드를 수정하는 것이 그 기능을 가장 빠르게 추가하는 길이다.** \
  대부분의 경우, `새로 작성하는 코드 < 기존코드의 수정`인 경우가 많다.
- **섣불리 추측하지 말고 성능을 측정해보자** \
  대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다.\
  그래서 코드 전체를 최적화 한다면 그중 90%는 효과가 거의 없다.

---

## 리팩토링 시점

#### 준비를 위한 리팩토링

리팩토링하기 가장 좋은 시점은 `기능을 새로 추가하기 직전` 이다.

기능추가를 쉽게 해줄 수 있는 개선요소를 찾고,\
구조를 살짝 바꿨을 때 다른작업을 하기가 쉬워질만한 부분을 수정한다.

- 오류를 발생시키는 코드가 여러곳에 복제되어 있지는 않은지

에시로는,

- 문제가 생기는 함수내의 리터럴들을 매개변수로 뺀다.
- 문제가 생기는 코드들을 하나로 합친다.

등이 있다.

#### 이해를 위한 리팩토링

`코드가 하는일을 파악해가는 단계`에서도 리팩토링을 해야한다.

이 시점에서는 코드를 이해하기 쉽게 만드는것이 중요하다.

- 조건부 로직의 구조가 이상하진 않은지
- 코드의 의도가 애매하진 않은지
- 로직이 쓸데없이 복잡하진 않은지

예시로는,

- 변수의 이름을 바꾼다.
- 긴 함수를 잘게 나눈다.
- 함수를 매개변수화 한다.

등이 있다.

#### 계획된 리팩터링, 수시로하는 리팩터링

리팩터링과 프로그래밍은 같이하는 활동이다.\
보기싫은 코드를 발견하면 그때그때 리팩토링하자.\
즉, `계획된 리팩토링은 최소한으로` 줄어야 한다.

계획된 리팩토링으로는,\
코드리뷰를 통해 팀원들과 함께하는 리팩토링등이 있다.

#### 리팩토링을하지 말아야 할 떄

- **API 혹은 API를 다루듯 호출해서 쓰는 코드** \
  -> 내부동작을 이해해야 리팩토링이 가능하기때문에, 굳이 내부동작을 알 필요가 없는 코드들은 리팩토링 하지 않는다.
- **리팩터링하는 것보다 처음부터 새로 작성하는게 쉬울 때** \
  -> 사실 이 부분은 명확히 파악하기가 힘들다.
- **단순히 코드를 이쁘게 보이기 위해 정리하려는 경우** \
  -> 리팩터링의 본질은 코드베이스를 예쁘게 꾸미는데 있지 않다. 오로지 경제적인 이유로 하는 것이다.

---

## 고려해야 할 것들

#### 아키텍쳐와 애그니

결론부터 말하자면 다음과 같다.

```
- 현재까지 요구사항만을 완벽히 해결하도록 설계한다.
- 변화가 일어났을 때에 아키텍쳐도 리펙터링해서 바꾼다.
    - 소프트웨어 복잡도에 영향을 주지 않는 매커니즘은 유연성 매커니즘을 통해 해결한다.
    - 복잡도를 높일 수 있는 유연성 메커니즘은 반드시 검증은 거친후에 추가한다.
```

이러한 방식은 `YAGNI`(you aren't going to need it) 또는 `간결한 설계`, `점진적 설계`라고도 부르머, 리펙터링의 뒷받침이 필수다.

과거에는 코딩전에 모든 아키텍처를 확정지어야 했으나,\
최근 대부분의 회사에서 사용하는 애자일 방식의 개발에서는 요구사항이 수시로 변화하기에 `초기에 아키텍쳐의 설계를 확정할 수 없다는 문제점`이 있다.

리펙터링이 중요시되기 전의 과거에는 이러한 문제를 한가지 방법으로는 `유연성 매커니즘`을 심어두는 방식이 있다.\
대표적인 예로 함수에 다양한 예상시나리오에 대한 매개변수를 심어둔다거나 하는 방법이있다.

그러나 모든 상황을 고려해 마구잡이로 유연성 매커니즘을 심어주다보면,

- 당장 쓰임에 비해 함수가 너무 복잡해짐
- 과거에 추가해둔 매개변수로 새로운 매개변수를 추가하기가 어려워짐

등의 문제점이 있다.

따라서 선제적인 아키텍처에 너무 몰두할게 아니라,\
나중에 문제를 더 깊이 이해하게 되었을 때, 처리하는 쪽이 훨씬 나을 수 있다.

#### 코드 소유권

코드 소유권이 우리팀이 아니라면, 리팩토링을 할 수 없다.

이럴 경우 인터페이스를 파서 리팩토링을 진행한다.\
협업 단계에서 `코드 소유권을 잘게 나누는 것을 지양하자`.

#### 브랜치

팀마다 git flow가 다르지만, 요즘 대부분은 기능별 브랜치 전략을 사용한다.

그러나, 개인 독립브랜치에서 오랜기간 많은 작업을 할 경우, master에 merge시에 문제가 발생한다.\
내가 작업하는 내용을 다른 팀원들과 공유할 수 없기 때문에, merge를 통해 master에 많은 부분이 수정되고 추가되면 내가 개발 중인 내용에 붙이는데 많은 문제가 발생할 수 있다.

기능별 `브랜치의 통합주기를 2~3일` 단위로 짧게 관리하는 방법이 대안이 될 수 있다. (a.k.a CI)\
2~3일 단위로 master에 주기적으로 merge하여, 다른 브랜치들과의 차이가 크게 벌어지는 브랜치가 없어 복잡도를 낮춘다.

이를 위해선, 거대한 기능을 짤개 쪼개는 연습을 하자.

그러나 브랜치를 자주 통합할 수만 있다면, 기능별 브랜치 전략을 사용해도 무방하다.

#### 테스트

테스트는 항상 염두해두자.\
리팩터링 과정에서 사이드 이팩트 발생에 대한 불안감을 해소할 수 있다.

#### 레거시코드

대규모 레거시 시스템을 테스트코드 없이 명료하게 리팩토링 하기는 어렵다.\
테스트 보강을 통해 이를 해소할 수 있고, 테스트 보강의 전략 중 하나는 `테스트를 추가할 틈새를 찾아서 테스트 한다`는 것이다.

테스트 코드의 보강만으로 리팩터링이 어려울 경우,\
`관련된 부분끼리 나눠서 하나씩 공략`해보자.
한 부분을 훑고 넘어갈 때마다 조금이라도 개선하려고 해보자.

#### 성능

`직관적인 설계 vs 성능`이 문제가 되는 경우가 많다.\
리펙터링을 하면 성능이 느려지는건 사실이지만

> 성능이 느려지더라도 리펙토링을 하자
> 당장은 느려질 지언정 추후에 성능을 튜닝하기 더 수월해진다.

성능이 느려져서 리펙토링이 필요할 경우, \
**섣불리 추측하지 말고 성능을 측정해보자**, 대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다.\
그래서 코드 전체를 최적화 한다면 그중 90%는 효과가 거의 없다. 다음의 절차를 따라서 성능을 테스트해본 후 정확한 원인을 파악하자

1. 프로파일러로 시간과 공간을 많이 잡아먹는 지점을 파악
2. 그 속에서 큰 영향을 주는 작은 부분들을 찾자
3. 리펙토링으로 최적화 (작은단계로 나눠서 진행)

---
